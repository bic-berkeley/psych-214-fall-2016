<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Slice timing exercise &mdash; Functional MRI methods</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/copybutton.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Functional MRI methods" href="index.html" />
    <link rel="next" title="Slice timing exercise" href="slice_timing_solution.html" />
    <link rel="prev" title="Otsu’s method for binarizing images" href="otsu_threshold.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p><span class="math">\(\newcommand{L}[1]{\| #1 \|}\newcommand{VL}[1]{\L{ \vec{#1} }}\newcommand{R}[1]{\operatorname{Re}\,(#1)}\newcommand{I}[1]{\operatorname{Im}\, (#1)}\)</span></p>
<div class="section" id="slice-timing-exercise">
<h1>Slice timing exercise<a class="headerlink" href="#slice-timing-exercise" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>For code template see: <a class="reference download internal" href="_downloads/slice_timing_code.py" download=""><code class="xref download docutils literal"><span class="pre">slice_timing_code.py</span></code></a>;</li>
<li>For solution see: <a class="reference internal" href="slice_timing_solution.html"><span class="doc">Slice timing exercise</span></a>.</li>
</ul>
<p>See: <a class="reference external" href="https://matthew-brett.github.io/teaching/slice_timing.html">slice timing correction</a> for the background to this exercise.</p>
<div class="nbplot container">
</div>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#: Import common modules</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>  <span class="c1"># the Python array package</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">suppress</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># print to 4 DP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>  <span class="c1"># the Python plotting package</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="kn">as</span> <span class="nn">nib</span>
</pre></div>
</div>
</div>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#: Set defaults for plotting</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;image.cmap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;gray&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;image.interpolation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span>
</pre></div>
</div>
</div>
<p>Load the image <a class="reference download internal" href="_downloads/ds114_sub009_t2r1.nii" download=""><code class="xref download docutils literal"><span class="pre">ds114_sub009_t2r1.nii</span></code></a> with nibabel. Get the data:</p>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#: Load the image &#39;ds114_sub009_t2r1.nii&#39; with nibabel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Get the data array from the image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">nibabel</span> <span class="kn">as</span> <span class="nn">nib</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">nib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;ds114_sub009_t2r1.nii&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64, 64, 30, 173)</span>
</pre></div>
</div>
</div>
<p>As you remember, the first volume in this dataset is a lot different from the
rest, and this will mess up our interpolation in time.</p>
<p>So, we need to remove the first volume from the data first, using slicing:</p>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#: Remove the first volume by slicing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fixed_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fixed_data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(64, 64, 30, 172)</span>
</pre></div>
</div>
</div>
<p>We start off with example time-courses from the first and second slice.</p>
<p>Use slicing to get a z slice 0 time series for an example voxel at voxel
coordinates (23, 19, 0).</p>
<p>Do the same for a z slice 1 time series from (23, 19, 1).</p>
<p>Plot these time series against volume number on the same graph:</p>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Slice out time series for voxel (23, 19, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Slice out time series for voxel (23, 19, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Plot both these time series against volume number, on the same graph</span>
</pre></div>
</div>
</div>
<p>The scanner collected slices for these data in an &#8220;ascending
interleaved&#8221; order. That is, the scanner first collected z slice 0, then
z slice 2, up to z slice 28. It then went back to collect z slice 1, 3,
5 up to z slice 29.</p>
<p>That means the scanner started collecting slice 0 in each volume, at the
beginning of the volume.</p>
<p>The TR (time to collect one volume) is 2.5 seconds.</p>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#: The time between scans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">TR</span> <span class="o">=</span> <span class="mf">2.5</span>
</pre></div>
</div>
</div>
<p>Make a time vector, length 172, that corresponds to the start time in seconds
of each volume. This also gives the slice 0 start times.</p>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Make time vector containing start times in second of each volume,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- relative to start of first volume.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Call this `slice_0_times`</span>
</pre></div>
</div>
</div>
<p>The scanner starts to collect z slice 1 exactly half way through the volume
(half way through the TR). Make a new vector that is the start time of
acquisition of slice 1.</p>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Make time vector containing start times in seconds of z slice 1,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- relative to start of first volume.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Call this `slice_1_times`</span>
</pre></div>
</div>
</div>
<p>Now plot the first 10 values for the slice 0 times, against the first 10
values of the slice 0 time series.</p>
<p>Do the same plot for the first 10 values of the slice 1 times, against the
first 10 values of the slice 1 time series.</p>
<p>Use the <code class="docutils literal"><span class="pre">:+</span></code> line marker for the plots to get the actual position of the
points, and dotted lines between them.</p>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Plot first 10 values of slice 0 times against first 10 of slice 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- time series;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Plot first 10 values of slice 1 times against first 10 of slice 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- time series.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Use &#39;:+&#39; marker</span>
</pre></div>
</div>
</div>
<p>Import <code class="docutils literal"><span class="pre">InterpolatedUnivariateSpline</span></code> from <code class="docutils literal"><span class="pre">scipy.interpolate</span></code>. Make a new
linear (<code class="docutils literal"><span class="pre">k=1</span></code>) interpolation object for slice 1, with the slice 1 times and
values.</p>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Import `InterpolatedUnivariateSpline` from `scipy.interpolate`</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Make a new linear (`k=1`) interpolation object for slice 1, with</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- slice 1 times and values.</span>
</pre></div>
</div>
</div>
<p>Call the object you got with the slice 0 times, to get the estimated time
series values for slice 1, if slice 1 had been collected at the same time as
slice 0:</p>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Call interpolator with `slice_0_times` to get estimated values</span>
</pre></div>
</div>
</div>
<p>Repeat the plot of the first 10 values of the time series. This time, on the
same plot, add the estimated values for slice 1, if they had been collected at
the same time as slice 0. Use a black <code class="docutils literal"><span class="pre">x</span></code> for the estimated points (marker
<code class="docutils literal"><span class="pre">'kx'</span></code>):</p>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Plot first 10 values of slice 0 times against first 10 of slice 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- time series;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Plot first 10 values of slice 1 times against first 10 of slice 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- time series;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Plot first 10 values of slice 0 times against first 10 of</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- interpolated slice 1 time series.</span>
</pre></div>
</div>
</div>
<p>Use numpy to make a new copy of the data matrix. This will contain the slice
time corrected values for all voxels. Copying the data matrix will give us the
data we want for slice 0, because we want to keep the values for z slice 0
unchanged.  We need to make a copy of the array to make sure we do not
overwrite the original data.</p>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Copy old data to a new array</span>
</pre></div>
</div>
</div>
<p>Loop over every x voxel coordinate, and then loop over every y voxel
coordinate.</p>
<p>For each x, y voxel coordinate:</p>
<ul class="simple">
<li>extract the time series at this x, y coordinate for slice 1;</li>
<li>make a linear interpolator object with the slice 1 times and the extracted
time series;</li>
<li>resample this interpolator at the slice 0 times;</li>
<li>put this new resampled time series into the new data at the same position.</li>
</ul>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#- loop over all x coordinate values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- loop over all y coordinate values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- extract the time series at this x, y coordinate for slice 1;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- make a linear interpolator object with the slice 1 times and the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- extracted time series;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- resample this interpolator at the slice 0 times;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- put this new resampled time series into the new data at the same</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- position.</span>
</pre></div>
</div>
</div>
<p>Now we need to do the same thing for all the z slices.</p>
<p>To do this, we want to construct an offset vector (call it <code class="docutils literal"><span class="pre">time_offset</span></code>) of
length (number of z slices) such that adding the <code class="docutils literal"><span class="pre">time_offset[z]</span></code> to the
acquisition time of the first slice will give us the time of acquisition of
slice <code class="docutils literal"><span class="pre">z</span></code>. The next few steps are to get to that <code class="docutils literal"><span class="pre">time_offset</span></code> vector.</p>
<p>First, make a new vector <code class="docutils literal"><span class="pre">acquisition_order</span></code> that is length 30, where
<code class="docutils literal"><span class="pre">acquisition_order[i]</span></code> is the order of acquisition of slice index <code class="docutils literal"><span class="pre">i</span></code>. For
example, the first 4 elements of <code class="docutils literal"><span class="pre">acqusition_order</span></code> should be 0, 15, 1, 16.</p>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Make acquisition_order vector, length 30, with values:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- 0, 15, 1, 16 ... 14, 29</span>
</pre></div>
</div>
</div>
<p>Divide the acquisition order vector by number of slices, and multiply by the
TR, to get the time offset for each z slice, relative to the start of the
scan:</p>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#- Divide acquisition_order by number of slices, multiply by TR</span>
</pre></div>
</div>
</div>
<p>Now we can do our whole slice time correction, for every slice.</p>
<ul>
<li><p class="first">For each z coordinate (slice index):</p>
<ul>
<li><p class="first">Make a time vector by adding the slice time offset for this slice, to the
<code class="docutils literal"><span class="pre">slice_0</span></code> times. Call this the <code class="docutils literal"><span class="pre">slice_z_times</span></code> vector;</p>
</li>
<li><p class="first">For each x coordinate:</p>
<blockquote>
<div><ul>
<li><p class="first">For each y coordinate:</p>
<blockquote>
<div><ul class="simple">
<li>extract the time series at this x, y, z coordinate;</li>
<li>make a linear interpolator object with the <code class="docutils literal"><span class="pre">slice_z_times</span></code> and
the extracted time series;</li>
<li>resample this interpolator at the slice 0 times;</li>
<li>put this new resampled time series into the new data at the same
position</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</li>
</ul>
<div class="nbplot container">
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1">#- For each z coordinate (slice index):</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- # Make `slice_z_times` vector for this slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- ## For each x coordinate:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- ### For each y coordinate:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- #### extract the time series at this x, y, z coordinate;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- #### make a linear interpolator object with the `slice_z_times` and</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#-      the extracted time series;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- #### resample this interpolator at the slice 0 times;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#- #### put this new resampled time series into the new data at the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#-      same position</span>
</pre></div>
</div>
</div>
<p>Congratulations - you have just done slice timing correction on this 4D image.</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">PSYCH 214 Fall 2016</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="syllabus.html">Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="preparation.html">Preparation</a></li>
<li class="toctree-l1"><a class="reference internal" href="logistics.html">Logistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="labs.html">Labs</a></li>
<li class="toctree-l1"><a class="reference internal" href="projects.html">Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="topics.html">Course material by topic</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercises.html">Exercises and homework</a></li>
<li class="toctree-l1"><a class="reference internal" href="example_data.html">Example datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="_downloads">Website downloads</a></li>
    
    <li class="toctree-l1"><a href="https://nipy.bic.berkeley.edu/psych-214">Dataset downloads</a></li>
    
    <li class="toctree-l1"><a href="https://github.com/psych-214-fall-2016">Github organization</a></li>
    
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="otsu_threshold.html" title="previous chapter">Otsu&#8217;s method for binarizing images</a></li>
      <li>Next: <a href="slice_timing_solution.html" title="next chapter">Slice timing exercise</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Matthew Brett, JB Poline.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/slice_timing_exercise.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>